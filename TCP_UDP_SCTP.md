
     TCP 的一些`特性`一旦`理解`，就很容易写出健壮的客户端，服务端程序， 也容易用netstat等工具调试
    
 UDP
 ===
 udp 每个数据报有长度， TCP是字节流协议无记录边界，也就是说不知道数据结尾地址
    
 TCP
 ===
* 字节关联`序号`
* `流量控制`，告知对方，我一次能接受多少字节
* `RTT`(Rout-trip time)，估算往返时间
* `超时`， 超时未送达，`中断连接`告知用户
* 全双工， `每个数据流方向`有 `序列号`、`窗口大小`状态信息
    
 TCP 三次握手
 ===========
* client SYN J 发送客户端将在待建立的连接中，发送的`初始数据序号` J
* server 确认(ACK J+1)客户的SYN,同事发送server SYN K 在待建立连接中数据的`初始序号` K
* client ack server的 SYN K+1 告知我接收到了server的同步请求，此时连接建立
* 被动方，在网络延迟，`小于200ms时`，`SYN,ACK一起发送`，在`延迟比较大`的情况下两个信息将`分开发送`  
  
* ACK 序号的本质含义，`期待的下一个数据序号`
 
 TCP 选项
 ========
 每个SYN可以发送多个选项，标示连接的一些信息
 * MSS (Message Segment size), 告知对端，`本机` `当前连接`愿意`接受`的，`最大分节大小`， 随SYN发送
 * SO_RCVBUF，窗口规模  
    原TCP协议TCP窗口字段`16字节`，最大65535，在一些`高速网络中，要求更大窗口`   
    此为新家选项，so只有: 
    1.客户端，在`server也随SYN 发送SO_RCVBUF`才扩展   
    2.server，在`请求SYN有此选项`才发送该选项  
    总结来说就是只处理双方都理解的选项  
 
 TCP连接终止
 ==============
 * TCP 关闭连接执行四次握手  
 
 * 主动关闭方 发送FIN J, 等待对端ACK J+1
 * 被动关闭方 接受到FIN ,等待 ACK J+1，接受到FIN会作为EOF,传递给客户进程
 * 主动方数据发送完毕（在收到FIN后，被动方还能继续发送数据，称为`半关闭状态`）， 发送FIN K , 等待ACK k+1
 * 主动方，接收FIN K 发送ACK K+1 各自关闭  
 
 * ACK J+1 ,FIN K可能同时发出,则三次交互OK
 * 可能双方同时FIN， 各自分别ACK
 
 * 状态可以通过netstat查看
 
 TCP TIME_WAIT状态
 =================
 
 * 2MSL 确保ack超时重复发送ACK能成功到的
 * 确保数据在网络中消失，在同一地址对重建立时，不会有老连接的数据
 
 TCP 输出
 ========
 * 每个连接有一个写缓冲区，慢了之后阻塞状态下，应用线程阻塞，write不返还回
 * 每个数据节在收到ACK之前维护副本，收到可弃之矣
 * 套接字SO_SENDBUF可修改缓冲区大小
 
 UDP 输出
 ========
 * SO_SENDBUF 标示UDP数据报大最大限制，大于之，则返回EMSGSIZE
 * UDP写入成功返回，只是标示数据都已成功加入，数据链路层的数据输出队列，超出队列大小范湖ENOBUFS

    原TCP协议TCP窗口字段`16字节`，最大65535，在一些`高速网络中，要求更大窗口`   
    原TCP协议TCP窗口字段`16字节`，最大65535，在一些`高速网络中，要求更大窗口`   
